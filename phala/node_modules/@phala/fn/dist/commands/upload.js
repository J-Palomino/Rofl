"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const upath_1 = tslib_1.__importDefault(require("upath"));
const sdk_1 = require("@phala/sdk");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const PhatBaseCommand_1 = tslib_1.__importDefault(require("../lib/PhatBaseCommand"));
class Upload extends PhatBaseCommand_1.default {
    async run() {
        var _a;
        const rpc = this.parsedFlags.rpc || process.env.MUMBAI_RPC_URL || process.env.POLYGON_RPC_URL || (await this.promptRpc());
        const consumerAddress = this.parsedFlags.consumerAddress || (await this.promptConsumerAddress());
        let derived = 'blank@0.0.0';
        try {
            const packageJson = JSON.parse(node_fs_1.default.readFileSync(upath_1.default.join(process.cwd(), 'package.json'), 'utf8'));
            derived = `${packageJson.name}@${packageJson.version}`;
        }
        catch (err) {
        }
        const buildScriptPath = await this.buildOrGetScriptPath();
        // connect to the endpoint
        const endpoint = this.getEndpoint();
        const [apiPromise, registry] = await this.connect({ endpoint });
        const provider = await this.getProvider({ apiPromise });
        // query the brick profile contract id
        this.action.start('Querying your Dashboard Profile contract ID');
        const brickProfileContractId = await this.getBrickProfileContractId({
            endpoint,
            registry,
            provider,
        });
        const brickProfileAbi = await this.loadAbiByContractId(registry, brickProfileContractId);
        const brickProfile = await (0, sdk_1.getContract)({
            client: registry,
            contractId: brickProfileContractId,
            abi: brickProfileAbi,
            provider,
        });
        this.action.succeed(`Your Dashboard Profile contract ID: ${brickProfileContractId}`);
        // instantiating the ActionOffchainRollup contract
        this.action.start('Instantiating the ActionOffchainRollup contract');
        const rollupAbi = await this.getRollupAbi();
        const blueprint = new sdk_1.PinkBlueprintPromise(apiPromise, registry, rollupAbi, rollupAbi.info.source.wasmHash.toHex());
        const instantiateResult = await blueprint.send.withConfiguration({
            provider,
        }, rpc, consumerAddress, node_fs_1.default.readFileSync(buildScriptPath, 'utf8'), this.parsedFlags.coreSettings || '', brickProfileContractId);
        await instantiateResult.waitFinalized();
        const { contract } = instantiateResult;
        contract.provider = provider;
        this.action.succeed(`The ActionOffchainRollup contract has been instantiated: ${contract.address.toHex()}`);
        // select an external account
        const externalAccountId = await this.promptEvmAccountId({
            contract: brickProfile,
        });
        // check your settings
        this.action.start('Checking your settings');
        const { output: attestorQuery } = await contract.q.getAttestAddress();
        const attestor = attestorQuery.asOk.toHex();
        const selectorUint8Array = (_a = rollupAbi.messages
            .find((i) => i.identifier === 'answer_request')) === null || _a === void 0 ? void 0 : _a.selector.toU8a();
        const selector = Buffer.from(selectorUint8Array).readUIntBE(0, selectorUint8Array.length);
        const actions = [
            {
                cmd: 'call',
                config: {
                    codeHash: rollupAbi.info.source.wasmHash.toHex(),
                    callee: contract.address.toHex(),
                    package: derived,
                    selector,
                    input: [],
                },
            },
            {
                cmd: 'log',
            },
        ];
        const { output: numberQuery } = await brickProfile.q.workflowCount();
        const num = numberQuery.asOk.toNumber();
        this.action.succeed();
        const projectName = await this.promptProjectName(`My Phat Contract ${numberQuery.asOk.toNumber()}`);
        // setting up the actions
        this.action.start('Setting up the actions');
        await brickProfile.exec.addWorkflowAndAuthorize({
            args: [
                projectName,
                JSON.stringify(actions),
                externalAccountId
            ],
            waitFinalized: true,
        });
        const workflowId = numberQuery.asOk.toNumber();
        this.action.succeed(`ðŸŽ‰ Your workflow has been added, you can check it out here: https://dashboard.phala.network/workflows/${brickProfileContractId}/${num}`);
        this.log(`You need connect Phat Contract and your EVM Smart Contract together to make it work:\n`);
        this.log(chalk_1.default.green(`MUMBAI_PHALA_ORACLE_ATTESTOR=${attestor} WORKFLOW_ID=${workflowId} npm run test-set-attestor`));
        this.log('\nAnd this is for the mainnet:\n');
        this.log(chalk_1.default.green(`POLYGON_PHALA_ORACLE_ATTESTOR=${attestor} WORKFLOW_ID=${workflowId} npm run main-set-attestor`));
        this.log(`\nYou can continuing update the Phat Contract script with following command:\n`);
        this.log(chalk_1.default.green(`npx @phala/fn update --mode dev --workflowId=${workflowId}`));
        this.log(`\nAnd this one is for mainnet:\n`);
        this.log(chalk_1.default.green(`npx @phala/fn update --workflowId=${workflowId}`));
        this.log('');
        process.exit(0);
    }
}
Upload.description = 'Upload JS to Phat Contract';
Upload.args = {
    ...PhatBaseCommand_1.default.args
};
Upload.flags = {
    ...PhatBaseCommand_1.default.flags
};
exports.default = Upload;
