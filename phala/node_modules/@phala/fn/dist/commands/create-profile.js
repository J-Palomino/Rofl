"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const sdk_1 = require("@phala/sdk");
const accounts_1 = require("viem/accounts");
const utils_1 = require("viem/utils");
const util_crypto_1 = require("@polkadot/util-crypto");
const util_1 = require("@polkadot/util");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const PhatBaseCommand_1 = tslib_1.__importDefault(require("../lib/PhatBaseCommand"));
const MINIMAL_PHA = 50;
class CreateDashboardProfile extends PhatBaseCommand_1.default {
    async run() {
        const { generate, type: accountType, evmRpcEndpoint, addressIndex } = this.parsedFlags;
        if (!generate) {
            if (!this.parsedFlags.mnemonic
                && !this.parsedFlags.privateKey
                && !this.parsedFlags.suri
                && !process.env.PRIVATE_KEY
                && !process.env.POLKADOT_WALLET_SURI
                && !process.env.MNEMONIC) {
                return this.error('You need specified one of --mnemonic, --privateKey, --suri or --generate to continuing.');
            }
        }
        else {
            const mnemonic = (0, accounts_1.generateMnemonic)(accounts_1.english);
            this.log('\nPlease copy the following recovery phrase and keep it safe.\n');
            this.log(chalk_1.default.red(mnemonic), '\n');
            if (accountType === 'substrate') {
                const suri = (0, util_1.u8aToHex)((0, util_crypto_1.mnemonicToMiniSecret)(mnemonic));
                this.parsedFlags.suri = suri;
                this.log('Please run following command to save your account to .env file.\n');
                this.log(chalk_1.default.green(`echo 'POLKADOT_WALLET_SURI=${suri}' >> .env`));
            }
            else if (accountType === 'evm') {
                this.warn('You are generating EVM account, please note it only available on PoC6 testnet now.');
                const account = (0, accounts_1.mnemonicToAccount)(mnemonic, { addressIndex });
                this.parsedFlags.privateKey = (0, utils_1.toHex)(account.getHdKey().privateKey);
                this.log('');
                this.log('Please run following command to save your account to .env file.\n');
                this.log(chalk_1.default.green(`echo 'PRIVATE_KEY=${(0, utils_1.toHex)(account.getHdKey().privateKey)}' >> .env`));
            }
            else {
                return this.error('You need specified --type to continuing.');
            }
            this.log('');
            this.log(`You need at least ${MINIMAL_PHA} PHA to continuing.`);
            this.log('Learn more on get test tokens from Faucet: https://phala.network/posts/how-to-create-a-phat-dashboard-account-and-get-test-tokens');
            this.log('');
            this.log('Once you have tokens in account, rerun this command without --generate flag.');
            this.log('');
        }
        if (evmRpcEndpoint) {
            await this.verifyRpcEndpoint(evmRpcEndpoint);
        }
        // connect to the endpoint
        const endpoint = this.getEndpoint();
        const [apiPromise, registry, type] = await this.connect({ endpoint });
        const provider = await this.getProvider({ apiPromise });
        this.log('Your address is', chalk_1.default.blue(provider.address));
        if (generate) {
            return process.exit(0);
        }
        this.log('');
        // check if profile already exists
        this.action.start('Checking your Dashboard Profile contract ID');
        const brickProfileFactoryContractId = await this.getBrickProfileFactoryContractId(endpoint);
        const brickProfileFactoryAbi = await this.loadAbiByContractId(registry, brickProfileFactoryContractId);
        const brickProfileFactory = await (0, sdk_1.getContract)({
            client: registry,
            contractId: brickProfileFactoryContractId,
            abi: brickProfileFactoryAbi,
            provider,
        });
        const { output } = await brickProfileFactory.q.getUserProfileAddress();
        if (output.isOk && output.asOk.isOk) {
            this.action.succeed(`Your Dashboard Profile already exists, contract ID: ${output.asOk.asOk.toHex()}`);
            process.exit(0);
        }
        this.action.succeed('Your Dashboard Profile does not exist');
        // check balance
        this.action.start('Checking account balance');
        const accountQueryResult = await registry.api.query.system.account(provider.address);
        const balance = Number(accountQueryResult.data.free.toBigInt() / BigInt(1e12));
        if (balance < MINIMAL_PHA) {
            this.action.fail(`Insufficient on-chain balance, please go to ${type.isDevelopment || type.isLocal ? 'https://phala.network/faucet' : 'https://docs.phala.network/introduction/basic-guidance/get-pha-and-transfer'} to get more than ${MINIMAL_PHA} PHA before continuing the process.`);
            process.exit(0);
        }
        this.action.succeed(`Account balance: ${balance} PHA`);
        try {
            this.action.start('Creating your Dashboard Profile');
            await brickProfileFactory.exec.createUserProfile({
                waitFinalized: async () => {
                    const { output } = await brickProfileFactory.q.getUserProfileAddress();
                    const created = output && output.isOk && output.asOk.isOk;
                    if (!created) {
                        return false;
                    }
                    const result = await registry.getContractKey(output.asOk.asOk.toHex());
                    if (result) {
                        return true;
                    }
                    return false;
                }
            });
            // query profile
            const { output } = await brickProfileFactory.q.getUserProfileAddress();
            if (output.isErr) {
                throw new Error(output.asErr.toString());
            }
            const brickProfileContractId = output.asOk.asOk.toHex();
            const brickProfileAbi = await this.loadAbiByContractId(registry, brickProfileContractId);
            const brickProfile = await (0, sdk_1.getContract)({
                client: registry,
                contractId: brickProfileContractId,
                abi: brickProfileAbi,
                provider,
            });
            // unsafeConfigureJsRunner
            const jsRunnerContractId = await this.getJsRunnerContractId(endpoint);
            await this.unsafeConfigureJsRunner({
                contract: brickProfile,
                jsRunnerContractId,
            });
            // unsafeGenerateEtherAccount
            const { output: queryCount } = await brickProfile.q.externalAccountCount();
            if (queryCount.isErr) {
                throw new Error(queryCount.asErr.toString());
            }
            const externalAccountCount = output.asOk.toNumber();
            if (externalAccountCount === 0) {
                await this.unsafeGenerateEtherAccount({
                    contract: brickProfile,
                    externalAccountCount,
                    evmRpcEndpoint: evmRpcEndpoint || (type.isDevelopment || type.isLocal) ? 'https://polygon-mumbai.g.alchemy.com/v2/YWlujLKt0nSn5GrgEpGCUA0C_wKV1sVQ' : 'https://polygon-mainnet.g.alchemy.com/v2/W1kyx17tiFQFT2b19mGOqppx90BLHp0a',
                });
            }
            this.action.succeed(`Profile Created.`);
            this.log('');
            this.log(chalk_1.default.green('Your profile is ready to use.'));
            this.log('');
            this.log('You can continuing with CLI or Web UI: https://dashboard.phala.network/');
            process.exit(0);
        }
        catch (error) {
            this.action.fail('Failed to create Dashboard Profile.');
            return this.error(error);
        }
    }
    async unsafeGenerateEtherAccount({ contract, externalAccountCount, evmRpcEndpoint, }) {
        await contract.exec.generateEvmAccount({
            args: [evmRpcEndpoint],
            waitFinalized: async () => {
                const { output } = await contract.q.externalAccountCount();
                return output.isOk && output.asOk.toNumber() === externalAccountCount + 1;
            }
        });
    }
    async unsafeConfigureJsRunner({ contract, jsRunnerContractId, }) {
        await contract.exec.config({
            args: [jsRunnerContractId],
            waitFinalized: async () => {
                const { output } = await contract.q.getJsRunner();
                return (output.isOk &&
                    output.asOk.isOk &&
                    output.asOk.asOk.toHex() === jsRunnerContractId);
            }
        });
    }
}
CreateDashboardProfile.description = 'Create Dashboard Profile';
CreateDashboardProfile.args = {
    ...PhatBaseCommand_1.default.args
};
CreateDashboardProfile.flags = {
    ...PhatBaseCommand_1.default.flags,
    evmRpcEndpoint: core_1.Flags.string({
        description: 'EVM RPC endpoint',
        required: false,
    }),
    generate: core_1.Flags.boolean({
        description: 'Generate mnemonic and use for Phat Contract Dashboard.',
        required: false,
    }),
    type: core_1.Flags.string({
        description: 'One of substrate or evm. Default is substrate. NOTE: evm account support now only available on PoC6 testnet.',
        required: false,
        default: 'substrate',
        options: ['substrate', 'evm'],
        helpValue: 'substrate|evm',
    }),
};
exports.default = CreateDashboardProfile;
